# Laboratory Work 1, Ciphers Implementation

### Course: Cryptography & Security
### Author: Liviu Mocanu

----

## Theory
Cryptography is a branch of mathematics that deals with securing information,
also ensuring authentication and restricting access in an informational system.

Classic cryptography falls under the class of symmetric key cryptography and is cryptography
before the computer, hence the name pre-computational cryptography. In classic cryptography, algorithms were character-based and consisted of a series of elementary transformations
(substitutions and transpositions) of plaintext characters.

### Substitution ciphers

The substitution cipher is the cipher in which each character or group of
characters of the plaintext m is replaced by another character or group of characters in the ciphertext c,
decryption is done by applying reverse substitution on the encrypted text.

### Monoalphabetic substitution ciphers

Monoalphabetic substitution ciphers (monoalphabetic ciphers) are the ciphers in which each
plaintext character m is replaced by a corresponding ciphertext character c.
Representatives of this class are: the Caesar cipher, the Polybios cipher, etc.

### The Caesar Cipher

In this cipher, each letter of the plaintext is replaced by a new letter obtained by an alphabetical shift. The secret key k, which is the same for encryption as and
upon decryption, it consists of the number indicating the alphabetic displacement, i.e. $k \in \{1, 2, 3,…, n–1\}$, where n is the length of the alphabet. The encryption and decryption of the message with the Caesar cipher can be defined by the formulas
where x and y are the numeric representation of the respective plaintext character.

For example, for the plaintext $m=Caesar\ cipher$ and key $k = 7$ we get the ciphertext $c=Jhlzhy\ jpwoly$

Caesar's cipher is very easy to crack, so it is a very weak cipher. Thus, a cryptanalyst can get the plain text by trying all 25 keys.

### The Polybius Cipher

In the Polybius cipher, a separate encryption square is built for each alphabet, most often with the same number of columns and lines (but this is not a necessary condition). Square dimensions depend on the length n of the alphabet. To create the square, two integers are taken, the product of which is closest to n. The lines and columns are numbered. After this the letters of the alphabet are written in this box in their natural order. If there are not enough cells for the letters of the alphabet, 2 letters can be entered in a cell or a few letters can be omitted (usually with the lowest possible frequency). For the Latin alphabet, we can have Polibios 5×5 squares by placing I and J in the same square.

|||||||
|---|---|---|---|-----|---|
|   | m | o | u | s   | e |
| m | A | B | C | D   | E |
| u | F | G | H | I/J | K |
| s | L | M | N | O   | P |
| c | Q | R | S | T   | U |
| a | V | W | X | Y   | Z |

For example, with the table above, the plaintext VENI VIDI VICI is encrypted in

ma em us su ma su sm su ma su um su

The weak point of monoalphabetic encryption systems lies in the frequency of occurrence of characters in the text. If an encrypted text is long enough and the language in which the plaintext is written is known, the system can be broken through an attack based on the frequency of occurrence of letters.

### Polyalphabetic substitution ciphers

The difference between polyalphabetic and monoalphabetic ciphers consists in the fact that the substitution of a character varies in the text, depending on various parameters (position, context, etc.). This of course leads to a much larger number of possible keys. The first polyalphabetic encryption system is believed to have been created by Leon Battista in 1568. Some current applications still use such encryption systems.

### The Vigenere cipher

Like the Caesar cipher, the Vigenere cipher moves the letters, but unlike it, it cannot be easily broken into 26 combinations. The Vigenere cipher uses a multiple shift. The key is not made up of a single shift, but of several, being generated by several integers $k_{i}$, where $0 \le k_{i} \le 25$, if we take the Latin alphabet with 26 letters as a reference. Encryption is done as follows:

$c_i = m_i + k_i (mod\ 26)$

The key is usually a word, to be easier to remember and $k_i$ represents the position of the key letter in the alphabet.

Decryption for the Vigenere cipher is similar to encryption. The difference is that the key is subtracted from the ciphertext:

$m_i = c_i – k_i (mod\ 26)$

For example, for the plaintext $m=Per\ aspera\ ad\ astra$ and key $k = Super$ we get the ciphertext $c=Hyg\ ejhyhe\ rv\ uhxis$

The Vigenere cipher is a lot safer than the Caesar cipher for two reasons:

- the first reason is that the others do not know the length of the key;
- the second reason is that the number of possible solutions increases, for example, for the key length equal to 5, the number of combinations that would be necessary for the exhaustive search would be $26^5 = 11,881,376$.

### Homophonic ciphers

The homophonic ciphers are intermediate ciphers between mono and polyalphabetic systems. Its main purpose is to avoid the attack by the frequency of appearance of the characters. The idea used in these ciphers is the uniformization of frequencies of the appearance of the characters of the digit text (secondary alphabet), in order to make it difficult to cryptanalytic attacks. Thus, the letter A - with the highest frequency of occurrence in the primary alphabet - can be replaced for example with H, # or M.

### Polygraphic substitution

Polygraphic substitution is achieved by substituting blocks (polygrams) in the clear text instead of single letters, thus destroying the meaning, so useful in cryptanalysis, the frequencies of different characters.

In the case of the singular letters, the frequency of the letters in the number of the text is equal to the frequency of the corresponding letters in the clear text. This invariance of frequencies provides an amount of information sufficiently to the cryptanalyst to break the figure. To minimize the collateral information provided by the frequency of appearance of the letters, the number of $d$ groups (d-grams) was used. If a group of $d$ letters is substituted by another group of letters, the substitution is called polygraphic. The simplest polygraphic substitution is obtained for $d = 2$ when the $m_1m_2$ d-gram in the clear text is substituted with the $c_1c_2$ d-gram in the encrypted text.

### The Playfair cipher

A classic example for d-grams substitution is Playfair cipher.
||||||
|-----|---|---|---|---|
| P   | L | A | Y | F |
| I/J | R | B | C | D |
| E   | G | H | K | M |
| N   | O | Q | S | T |
| U   | V | W | X | Z |

The first letters in the above square (in general case - a rectangle) represent a keyword $k$ (the letters that are repeated are written once, in this example the key being $k= Playfair$), after which the square is completed with the letters of the alphabet in their natural order , without repetition. Then the encryption is executed according to the following rules:

- The plaintext is separated in d-grams (pairs of letters)

- A pair cannot have identical letter so for the separation of the identical letters, some separation characters are introduced which, as a rule, have a reduced occurrence frequency, such as the letter X. If the number of characters in the plaintext is odd, such a letter is added at the end of it. When deciphering, these added letters are omitted.

- If $m_1$ and $m_2$ are in the same column in the above square then $c_1$ and $c_2$ are obtained by a cyclical displacement of $m_1$ and $m_2$ from top to bottom. For example AH → BQ and OV → VL;

- If $m_1$ and $m_2$ are in the same row, then $c_1$ and $c_2$ are obtained by a cyclical movement to the right of the letters $m_1$ and $m_2$. For example PA → LY and NO → OQ;

- If $m_1$ and $m_2$ are not in the same line or column, then $c_1$ and $c_2$ are the characters in the intersection of the line and columns. For example RK → CG and PZ → FU;

The deciphering is executed according to the rules similar to those of encryption, reversing the direction.

Using the example above ($k = Playfair$) for the clear text m = "Hello world" we obtain the encrypted text $c = KG\ YV\ RV\ VQ\ GR\ CZ$. Here we introduced between letters $ll$ the letter X and an extra letter X at the end because the amount of characters of the plaintext in this case becomes odd. When deciphering according to the meaning of the message, the letter X is omitted.

The use of the Playfair cipher currently does not make sense because modern laptops can easily break the cipher in seconds.


## Objectives:

1. Get familiar with the basics of cryptography and classical ciphers.

2. Implement 4 types of the classical ciphers:
    - Caesar cipher with one key used for substitution,
    - Affine cipher
    - Vigenere cipher,
    - Xor cipher,
    - Playfair cipher. (additional)
    - Hill cipher (additional)
    - Polybius cipher (additional)

3. Structured the implementations in implementation package and interface in interfaceCipher package.


## Implementation description
All the ciphers in this laboratory work implement the Cipher interface in the interfaceCipher directory.
### Caesar's cipher
In order not to write similar code, I used the cyclic property of the cipher under modulo, where

```Cipher(n) = De-cipher(26-n)```

Instead, calling the same function as encrypt but with the shift value such that shift = 26-shift:

```
   @Override
    public String encrypt(String text) {
        return cipher(text, this.key);
    }

    @Override
    public String decrypt(String text) {
        return cipher(text, Cipher.ALPHABET_SIZE -this.key);
    }
```

In the cipher method, I am using the Caesar formula for encrypting with some additional checkings so that it works for 
speical characters like space and numbers, or lowercase letters too.

```
   if (Character.isUpperCase(currentChar)) {
       char ch = (char) (((int) currentChar + s - 65) % Cipher.ALPHABET_SIZE + 65);
       encryptedText.append(ch);
   } else ...
```

We must do the modulo from 0 to 25 (26 letters - it's like converting from ASCII to the english alphabet table) 
that's why we need to subtract 65 from 'A' => 0 (for A), 1 for B etc... once we computed the new encrypted character we
have to convert it to ASCII, so we add 65. Same for non-capitalized ASCII letters (a->z), we will have to use 97 instead of 65.

### Vigenere cipher

This cipher is similar to the Caesar cipher in implementation but instead of having a fixed key, 
the key is a word and each letter has its position in alphabet, so use that position instead of the fixed key in the Caesar cipher.
For generating key, the given keyword is repeated
in a circular manner until it matches the length of
the plain text.
```
for (int i = 0; ; i++) {
   if (key.length() >= len)
       i = 0;
   if (keyBuilder.length() == text.length())
       break;
   keyBuilder.append(keyBuilder.charAt(i));
}
```

In Vigenere cipher, to encrypt the plaintext we use a Vigenere table or Vigenere square. Vigenere table consists of the alphabet from A to Z written out 26 times in different rows, each alphabet shifted cyclically to the left compared to the previous alphabet, leads to the 26 possible Caesar ciphers.

```if (Character.isLetter(currentChar)) {
boolean isLower = Character.isLowerCase(message.charAt(i));

 char x = (char) (((Character.toUpperCase(message.charAt(i)) + key.charAt(i)) % Cipher.ALPHABET_SIZE) + 'A');

 encryptedMessage.append(isLower ? Character.toLowerCase(x) : x);
} else encryptedMessage.append(currentChar);
```

### Affine cipher

The Affine cipher is a type of monoalphabetic substitution cipher, wherein each letter in an alphabet is mapped to its numeric equivalent, encrypted using a simple mathematical function, and converted back to a letter.
It uses modular arithmetic to transform the integer that each plaintext letter corresponds to into another integer that correspond to a ciphertext letter. The encryption function for a single letter is
```
char x = (char) ((((a * (Character.toUpperCase(message.charAt(i)) - 'A')) + b) % ALPHABET_SIZE) + 'A');
```
```
E ( x ) = ( a x + b ) mod m 
modulus m: size of the alphabet
a and b: key of the cipher.
a must be chosen such that a and m are coprime.
```
In deciphering the ciphertext, we must perform the opposite (or inverse) functions on the ciphertext to retrieve the plaintext. Once again, the first step is to convert each of the ciphertext letters into their integer values. The decryption function is
```
D ( x ) = a^-1 ( x - b ) mod m
a^-1 : modular multiplicative inverse of a modulo m. i.e., it satisfies the equation
1 = a a^-1 mod m .
```
To find a multiplicative inverse we need to find a number x such that:
If we find the number x such that the equation is true, then x is the inverse of a, and we call it a^-1. The easiest way to solve this equation is to search each of the numbers 1 to 25, and see which one satisfies the equation.
```
[g,x,d] = gcd(a,m);    % we can ignore g and d, we dont need them
x = mod(x,m);    
```
If you now multiply x and a and reduce the result (mod 26), you will get the answer 1. Remember, this is just the definition of an inverse i.e. if a*x = 1 (mod 26), then x is an inverse of a (and a is an inverse of x)
```
char x = (char) (((a_inv * ((Character.toUpperCase(message.charAt(i)) + 'A' - b)) % ALPHABET_SIZE)) + 'A');
```
### Xor Cipher

XOR Encryption is an encryption method used to encrypt data and is hard to crack by brute-force method, i.e generating random encryption keys to match with the correct one.
The concept of implementation is to first define XOR – encryption key and then to perform XOR operation of the characters in the String with this key which you want to encrypt. To decrypt the encrypted characters we have to perform XOR operation again with the defined key. Here we are encrypting the entire String.
```
for (int i = 0; i < len; i++) {
   outputString.append((char) (message.charAt(i) ^ key));
}
```

### Playfair Cipher (additional)

In Playfair cipher, initially, a key table is created. The key table is a 5×5 matrix consisting of alphabets that acts as the key for encryption of the plaintext. Each of the 25 alphabets must be unique and one letter of the alphabet (usually ‘j’) is omitted from the table, as we need only 25 alphabets instead of 26. If the plaintext contains ‘j’, then it is replaced by ‘i’.


Process for Playfair Cipher: (*the next code snippets all are part of formatPlainText() method*)

- The plaintext message is split into pairs of two letters (digraphs). If the plaintext has an odd number of characters, append ‘x’ to the end to make the message of even length.
```
if (len % 2 == 1)
   text.append('x');
```
- Identify any double letters placed side by side in the plaintext and replace the second occurrence with an ‘x’ e.g. ‘hello’ -> ‘he lx lo’.
```
for (int i = 0; i < text.length()-1; i += 2) {
            if (text.charAt(i) == text.charAt(i + 1))
                text = new StringBuilder(text.substring(0, i + 1) + 'x' + text.substring(i + 1));
        }
```
- Now, locate the letters in the 5×5 key table.
```
addLettersToKey(tempKey);

        for (int i = 0, idx = 0; i < 5; i++)
            for (int j = 0; j < 5; j++)
                keyMatrix[i][j] = tempKey.charAt(idx++);
```
- Use the following rules for encryption of plaintext:
  - If the letters appear on the same row of your table, replace them with the letters to their immediate right respectively (wrapping around to the left side of the row if a letter in the original pair was on the right side of the row). 
  - If the letters appear on the same column of your table, replace them with the letters immediately below respectively (wrapping around to the top side of the column if a letter in the original pair was on the bottom side of the column)
  - If the letters are not on the same row or column, replace them with the letters in their own row but in the same column as the other letter.
```
for (String pair : messagePairs) {
   char ch1 = pair.charAt(0);
   char ch2 = pair.charAt(1);
   int[] pos1 = getCharPos(ch1);
   int[] pos2 = getCharPos(ch2);

   if (pos1[0] == pos2[0]) {
       pos1[1] = (pos1[1] + 1) % 5;
       pos2[1] = (pos2[1] + 1) % 5;
   } else if (pos1[1] == pos2[1]) {
       pos1[0] = (pos1[0] + 1) % 5;
       pos2[0] = (pos2[0] + 1) % 5;
   } else {
       int temp = pos1[1];
       pos1[1] = pos2[1];
       pos2[1] = temp;
   }
   encryptedText.append(keyMatrix[pos1[0]][pos1[1]]).append(keyMatrix[pos2[0]][pos2[1]]);
}
```
The decryption process of Playfair cipher is the same encryption process, but it is applied in a reverse manner. The receiver has the same key and can create the same key table, and he uses it to decrypt the ciphertext messages generated using that key.
## Conclusions
In conclusion, this laboratory work was an interesting initiation into cryptograhpy.
Even if some classical ciphers are well-known and not as effective anymore, 
it allowed me to dive deeper into the theory behind them and ultimately making my knowledge foundation stronger
into what a cipher is, and how they developed over time.